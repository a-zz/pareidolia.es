# Easy programming languages

A discussion brought by someone who asked me whether Python is an easy language to get started in coding. Spoiler alert: there's no such thing; an "easy" programming language will only be so in the appearance.

Generally speaking because the difficulty of programming isn't usually in the language but in the *business logic*: the activity intended to be modelled or supported by the program. Moreover, in a more practical approach, because of the fact that "easy" programming languages in unskilled hands will very soon make things very complicated. An "easy" programming language (e.g. interpreted, loosely typed) can be suitable for unskilled programmers *or* programs aimed at a long life cycle, *but no both things*.

I'll try to explain it.

The raw material for a program is the set of so-called "use cases": the detailed definitions of operations and data sets needed to achieve a certain goal supported by the program. E.g. think of a program aimed at the management of a courier service: you'll have to start by defining which data you need to do the job (sender info, recipient info, parcel size & weight, delivery deadline, delivery method, applicable fee, commercial discount, payment status, etc.); and then you need to define how to gather all that information in every possible practical situation (telephone order, online order, pickup at origin, sender handing over at a courier branch, etc.) and how it evolves within the logic or usual practice for the task. Those are the use cases for the program, those required to be implemented in order for the program to work as needed.

When developing a program there isn't (*there can't be*) more information or requirements than those dictated by the use cases known at that moment; specially when, as it's usual, the developers aren't involved in the target business themselves. A good programmer will focus on getting to know as much as possible of the customer's *current* business logic in order to model use cases and translate them into the language and support systems of choice for the implementation; but it's hard to anticipate the customer's future needs (it's usually hard for customers themselves).

Because, you know, a program's use cases are an alive set. Organizations grow (or shrink), expand their scope of activity, consolidate and optimize their processes, go digital on certain tasks previously done by other means, or even are forced into operative modifications because of external reasons such as regulatory changes. Because of all this, a production system will usually come often into the need of revamping to support new use cases, usually unpredictable (by the customer, not to say the programmer) at the moment it was first developed.

The cost of implementing new use cases is always progressively higher. As the program grows and matures new developments are usually harder to fit in and more likely to bring in *regressions*: unexpected bugs in procedures considered so far to be working fine. Eventually, implementing new use cases becomes so hard that it's cheaper (in a broad sense) to drop the program altogether and re-design it from scratch, considering at once all the current use cases and discarding those obsolete. Flexibility and adaptability are key concepts in IT; but every information device (application, operating system, service, hardware) will reach a point when a replacement is cheaper than an upgrade.

It must be emphasized that this will eventually happen to any program, but if the program was well thought of and done in the first place it'll probably happen later. And a program well done is one clean, tidy, coherent, well organized in functional modules with well defined dependencies among them, well documented. A good programmer can even anticipate (and implement without too much overhead) some amount of flexibility in places where it isn't needed initially but may come handy later. E.g. only one person will be using the program, but what if there's the need for concurrency later?; it'll only be used by a company, but what if it's to be shared sometime after?; it's to be installed on a certain OS, but what if it's needed to be migrated later? Factoring that flexibility in the initial design perhaps can be done at a low cost, but it's usually a pain when the program has grown and aged. 

For that matter, "easy" programming languages such as Python can be troublesome for two reasons. The first one is their usually gentle learning curve, which allows unskilled programmers to produce, almost on-the-fly, software which -apparently and initially- works. The second one is that those languages don't enforce nor encourage clean, tidy, organized coding. A language such as Java, e.g., enforces from the bottom up structured coding (at least in the form of packages and classes), enforces considering data types; enforces the handling (or at least acknowledging) of possible errors emerging from third-party functions; *enforces* in the sense that, when not done well, the program just won't compile, and so there won't be any chance for it to run. By contrast, I just need a plain-text editor to write a Python script in ten seconds, fire it immediately and see what happens; I'll think about it later (most probably too late, or never at all).

I don't mean I don't like Python(*), quite the opposite. For a skilled programmer can be terrifically productive: it's very expressive, the development cycle is really fast and there's a huge community of coders / solutions ecosystem out there, so any problem you may come across will very likely have been faced by someone else who's published a solution on the Internet. The issue with Python is that it can produce in inexperienced programmers a false feeling of skillfulness, which may lead them dare to accept projects beyond their true capacity. A tiny program for a simple task can probably be made by anyone; a program intended to support a company or organization, that is to be upgraded for many years and -probable- by different people, requires a very well designed and implemented codebase. In this, as in everything, experience pays off well.

(*) Except perhaps for the semantically meaningful indentation. I understand that's intended for legibility, but find it hard to accept logic driven by non-visible (or barely-visible) characters. Maybe I'm too old for Python :P